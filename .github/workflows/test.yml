# .github/workflows/auto-merge-dependabot.yml
name: Auto-merge Dependabot PRs

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  auto-merge:
    name: Auto-merge dependency PRs
    runs-on: ubuntu-latest

    # Only run for Dependabot PRs
    if: |
      github.event.pull_request.user.login == 'dependabot[bot]' ||
      github.actor == 'dependabot[bot]'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get PR details
        id: pr-details
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            return {
              number: pr.number,
              title: pr.title,
              body: pr.body || '',
              user: pr.user.login,
              draft: pr.draft,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              head_sha: pr.head.sha,
              base_ref: pr.base.ref
            };

      - name: Determine update type and risk level
        id: analyze-changes
        uses: actions/github-script@v7
        with:
          script: |
            const prDetails = ${{ steps.pr-details.outputs.result }};
            const title = prDetails.title.toLowerCase();
            const body = prDetails.body || '';

            let updateType = 'unknown';
            let riskLevel = 'high';
            let autoMergeAllowed = false;

            // Extract package information
            const packageMatch = title.match(/(?:bump|update|upgrade)\s+([^\s]+)/);
            const packageName = packageMatch ? packageMatch[1] : '';

            // Check if it's a dev dependency
            const isDevDependency = body.includes('devDependencies') ||
                                  title.includes('dev-dependencies') ||
                                  packageName.includes('@types/') ||
                                  packageName.match(/^(eslint|typescript)/);

            // Check for security updates
            const isSecurityUpdate = title.includes('security') ||
                                   title.includes('vulnerability') ||
                                   body.includes('vulnerability');

            // Check for breaking changes
            const hasBreakingChanges = body.includes('breaking change') ||
                                     body.includes('BREAKING CHANGE');

            // Determine update type
            if (title.includes('patch') || body.includes('patch')) {
              updateType = 'patch';
              riskLevel = 'low';
              autoMergeAllowed = true;
            } else if (title.includes('minor') || body.includes('minor')) {
              updateType = 'minor';
              riskLevel = isDevDependency ? 'low' : 'medium';
              autoMergeAllowed = !hasBreakingChanges;
            } else if (title.includes('major') || body.includes('major')) {
              updateType = 'major';
              riskLevel = 'high';
              autoMergeAllowed = isDevDependency && !hasBreakingChanges;
            }

            // Security updates override - always allow unless breaking
            if (isSecurityUpdate && !hasBreakingChanges) {
              autoMergeAllowed = true;
              riskLevel = 'medium';
            }

            console.log('Package:', packageName);
            console.log('Update type:', updateType);
            console.log('Risk level:', riskLevel);
            console.log('Auto-merge allowed:', autoMergeAllowed);

            return {
              updateType,
              riskLevel,
              autoMergeAllowed,
              packageName,
              isDevDependency,
              isSecurityUpdate,
              hasBreakingChanges
            };

      - name: Add analysis comment
        if: steps.analyze-changes.outputs.result
        uses: actions/github-script@v7
        with:
          script: |
            const analysis = ${{ steps.analyze-changes.outputs.result }};
            const prNumber = ${{ fromJson(steps.pr-details.outputs.result).number }};

            const emoji = analysis.autoMergeAllowed ? '‚úÖ' : '‚ö†Ô∏è';
            const decision = analysis.autoMergeAllowed ? 
              'Will auto-merge if all checks pass' : 
              'Requires manual review';

            const comment = emoji + ' **Auto-merge Analysis**\n\n' +
                    '**Package:** `' + analysis.packageName + '`\n' +
                    '**Update Type:** ' + analysis.updateType + '\n' +
                    '**Risk Level:** ' + analysis.riskLevel + '\n' +
                    '**Dev Dependency:** ' + (analysis.isDevDependency ? 'Yes' : 'No') + '\n' +
                    '**Security Update:** ' + (analysis.isSecurityUpdate ? 'Yes' : 'No') + '\n' +
                    '**Breaking Changes:** ' + (analysis.hasBreakingChanges ? 'Yes' : 'No') + '\n\n' +
                    '**Decision:** ' + decision;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      - name: Wait for status checks
        id: wait-for-checks
        if: fromJson(steps.analyze-changes.outputs.result).autoMergeAllowed
        uses: actions/github-script@v7
        with:
          script: |
            const maxWaitTime = 10 * 60 * 1000;
            const pollInterval = 30 * 1000;
            const startTime = Date.now();

            const prDetails = ${{ steps.pr-details.outputs.result }};
            const prNumber = prDetails.number;
            const headSha = prDetails.head_sha;

            while (Date.now() - startTime < maxWaitTime) {
              const { data: statusChecks } = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha
              });

              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha
              });

              const allStatuses = statusChecks.statuses || [];
              const allCheckRuns = checkRuns.check_runs || [];

              const relevantCheckRuns = allCheckRuns.filter(run => 
                run.name !== 'Auto-merge dependency PRs'
              );

              const hasChecks = allStatuses.length > 0 || relevantCheckRuns.length > 0;

              if (!hasChecks) {
                console.log('No status checks found yet, waiting...');
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
              }

              const failedStatuses = allStatuses.filter(status => 
                status.state === 'failure' || status.state === 'error'
              );
              const failedCheckRuns = relevantCheckRuns.filter(run =>
                run.conclusion === 'failure' || run.conclusion === 'cancelled' || run.conclusion === 'timed_out'
              );

              if (failedStatuses.length > 0 || failedCheckRuns.length > 0) {
                console.log('‚ùå Some checks failed');
                return { success: false, reason: 'checks_failed' };
              }

              const pendingStatuses = allStatuses.filter(status => status.state === 'pending');
              const pendingCheckRuns = relevantCheckRuns.filter(run =>
                run.status === 'queued' || run.status === 'in_progress'
              );

              if (pendingStatuses.length === 0 && pendingCheckRuns.length === 0) {
                console.log('‚úÖ All checks passed!');
                return { success: true, reason: 'checks_passed' };
              }

              const totalPending = pendingStatuses.length + pendingCheckRuns.length;
              console.log('‚è≥ Waiting for ' + totalPending + ' checks to complete...');
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            console.log('‚è∞ Timeout waiting for checks');
            return { success: false, reason: 'timeout' };

      - name: Check for merge conflicts
        id: check-conflicts
        if: fromJson(steps.wait-for-checks.outputs.result || '{"success":false}').success
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ fromJson(steps.pr-details.outputs.result).number }};

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            console.log(`PR mergeable: ${pr.mergeable}, state: ${pr.mergeable_state}`);

            if (pr.mergeable === false || pr.mergeable_state === 'dirty') {
              return { hasConflicts: true };
            }

            return { hasConflicts: false };

      - name: Auto-approve PR
        if: |
          fromJson(steps.wait-for-checks.outputs.result || '{"success":false}').success &&
          !fromJson(steps.check-conflicts.outputs.result || '{"hasConflicts":true}').hasConflicts
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ fromJson(steps.pr-details.outputs.result).number }};

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: '‚úÖ Auto-approved: All checks passed, safe to merge.'
              });
              console.log('‚úÖ PR approved');
            } catch (error) {
              console.log('Could not approve (may already be approved):', error.message);
            }

      - name: Merge PR with your authorship
        if: |
          fromJson(steps.wait-for-checks.outputs.result || '{"success":false}').success &&
          !fromJson(steps.check-conflicts.outputs.result || '{"hasConflicts":true}').hasConflicts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git with your details
          git config --global user.name "SamuelIVX"
          git config --global user.email "your-email@users.noreply.github.com"
          
          # Merge the PR
          gh pr merge ${{ fromJson(steps.pr-details.outputs.result).number }} \
            --squash \
            --auto \
            --subject "chore(deps): ${{ fromJson(steps.analyze-changes.outputs.result).updateType }} update"
      
      - name: Add merge success comment
        if: |
          fromJson(steps.wait-for-checks.outputs.result || '{"success":false}').success &&
          !fromJson(steps.check-conflicts.outputs.result || '{"hasConflicts":true}').hasConflicts
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ fromJson(steps.pr-details.outputs.result).number }};
            const analysis = ${{ steps.analyze-changes.outputs.result }};

            try {

              console.log(`‚úÖ Successfully merged PR #${prNumber}`);

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `üéâ **Auto-merged successfully!**\n\n` +
                      `All checks passed:\n` +
                      `- ‚úÖ Build successful\n` +
                      `- ‚úÖ Linting passed\n` +
                      `- ‚úÖ Type check passed\n` +
                      `- ‚úÖ No merge conflicts\n\n` +
                      `This ${analysis.updateType} update has been safely merged to main.`
              });

            } catch (error) {
              console.error('‚ùå Failed to merge:', error.message);

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è **Auto-merge failed**\n\nCould not merge: ${error.message}\n\nPlease merge manually.`
              });

              throw error;
            }

      - name: Comment if manual review needed
        if: |
          steps.analyze-changes.outputs.result &&
          !fromJson(steps.analyze-changes.outputs.result).autoMergeAllowed
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ fromJson(steps.pr-details.outputs.result).number }};
            const analysis = ${{ steps.analyze-changes.outputs.result }};

            let reasons = '';
            if (analysis.hasBreakingChanges) {
              reasons += '- ‚ö†Ô∏è Contains breaking changes\n';
            }
            if (analysis.updateType === 'major' && !analysis.isDevDependency) {
              reasons += '- üì¶ Major version update for production dependency\n';
            }
            if (analysis.riskLevel === 'high') {
              reasons += '- üî¥ High risk level\n';
            }

            const comment = 'üë§ **Manual review required**\n\n' +
                    'This PR requires your review because:\n' +
                    reasons +
                    '\n**Please review and merge manually if appropriate.**';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });